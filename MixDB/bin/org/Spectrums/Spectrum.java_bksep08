//contain various informations about a spectrum 
package org.Spectrums;

import java.io.*;
import java.util.Vector;
import java.util.Arrays;
import java.util.Iterator;
import java.util.Comparator;
import java.util.Collections;
import java.util.List;
import java.util.ArrayList;

public class Spectrum implements Comparable<Spectrum>, Serializable{
	//default value for vector representation
	public static final long serialVersionUID = 1L;
	private static double BINWIDTH = 1;
	private static double MINMASS = 0.5;
	private static double MAXMASS = 2000;
	//the peaks in this spectrum, we should always keep this list sorted
	//according to the mass
	private List <Peak> peaks;
	String spectrumName = "";
	String peptide;
	double parentMass;
	int charge;
	double modMass; //mass of any modification
	int modPos; //the position of modification
	double score = 0; //provide certain kind of score to this spectrum
	                  //we can utilize this field to order the spectrums
	int scanNumber = 0; //scan number of the spectrum
	double rmagnitue = 0; //magnitude in the square-rooted spectrum, use to compute cosine
	boolean isSqrtTrans = false;  //flagged whether this spectrum is sqrt normalized
	public Spectrum(){ //create dummy spectrum
			this.peaks =new ArrayList();
			this.spectrumName = "DUMMYSPEC";
			this.peptide = "DUMMYSEQ";
		    this.modMass = 0;
			this.modPos = 0;
			this.charge = 1;
			this.parentMass = 10000; //very large mass, so the dummy
			                         //is different than real spectra
			this.scanNumber = 0;
			this.rmagnitue = 0;
	}	
	//note in the peptide we also include the charge as well, since
	//we are using the peptide as key to group spectrum, thus spectrum
	//with same peptide AND same charge should be grouped together
	public Spectrum(List peaks, String peptide, double pm, int charge,
		double modMass, int modPos){
		this.peaks = peaks;
		this.peptide = peptide;
		this.parentMass = pm;
		this.charge = charge;
		this.modMass = modMass;
		this.modPos = modPos;
		this.rmagnitue = Math.pow(this.sumOfPeaks(), 0.5);
	}
	
	public Spectrum(List peaks, String peptide, String name, double pm, int charge,
			double modMass, int modPos, int scanNumber){
			this.peaks = peaks;
			this.peptide = peptide;
			this.parentMass = pm;
			this.charge = charge;
			this.modMass = modMass;
			this.modPos = modPos;
			this.spectrumName = name;
			this.scanNumber = scanNumber;
			this.rmagnitue = this.magnitude();//Math.pow(this.sumOfPeaks(), 0.5);
	}
	
	public Spectrum(String spectrumFile, String format){
		if(format.equals("MGF")){
			readSpectrumFromMGF(spectrumFile);
		}
	}
	
	public Spectrum readSpectrumFromNIST(String fileName){
		return new Spectrum();
	}
	
	//create a new spectrum by combining two spectrum together
	//note this is a simulated spectrum, so some of the field might
	//not make sense 
	public Spectrum(Spectrum s1, Spectrum s2, double scale1, double scale2){
		this(s1, s2, scale1, scale2, s1.isSqrtTrans&&s2.isSqrtTrans);
		if(s1.isSqrtTrans != s2.isSqrtTrans){
			System.err.println("warning:  one of the spectrum is sqrt-transformed");
		}
	}
	
	public Spectrum(Spectrum s1, Spectrum s2, double scale1, double scale2, boolean isSqrt){
		if(scale1 != 1){   //process scale so scale1 is one and relative abundance is with respect to first spectrum
			scale2 = scale2 /scale1; 
			scale1 = 1;
			//System.out.println("scale1: " + scale1 + "\tscale2: " + scale2);
		}
		if(isSqrt){ //if spectrum is sqrt transformed we need to first sqrt the alpha
			//System.out.println("spectrums have been sqrt");
			scale2 = Math.pow(scale2, 0.5);
		}
		//s1 = s1.toNormVector(BINWIDTH, MINMASS, MAXMASS);
		//s2 = s2.toNormVector(BINWIDTH, MINMASS, MAXMASS);
		//s1 = s1.toVector(BINWIDTH, MINMASS, MAXMASS);
		//s2 = s2.toVector(BINWIDTH, MINMASS, MAXMASS);
		this.peptide = s1.peptide + " & " +  s2.peptide;
		this.modMass = 0;
		this.modPos = 0;
		this.charge = s1.charge;
		this.peaks = new ArrayList();
		this.parentMass = Math.max(s1.parentMass, s2.parentMass);  //we use the larger mass for the mixed spectrum
		//note here we make the modMass of a mixture the difference of pm of the components
		this.modMass = this.parentMass - Math.min(s1.parentMass, s2.parentMass);
		Peak p1, p2;
		double mz1, mz2, combined; 
		int i = 0, j = 0;
		while(i < s1.peaks.size() && j < s2.peaks.size()){
			p1 = s1.peaks.get(i);
			p2 = s2.peaks.get(j);
			mz1 = p1.getMass();
			mz2 = p2.getMass();
			if(mz1 < mz2){
				this.peaks.add(new Peak(mz1, p1.getIntensity()));
				i++;
			}else if(mz1 == mz2){
				if(isSqrt){
					combined = (p1.getIntensity() + p2.getIntensity()*scale2) * (p1.getIntensity() + p2.getIntensity()*scale2);
					combined = combined - 2*p1.getIntensity()*scale2*p2.getIntensity(); //we want sqrt(a + b) not sqrt(a) + sqrt(b) so we subtract the extra here
					combined = Math.pow(combined, 0.5);
				}else{
					combined = p1.getIntensity() + p2.getIntensity()*scale2;	
				}
				this.peaks.add(new Peak(mz1, combined));
				i++;
				j++;
			}else {
				this.peaks.add(new Peak(mz2, p2.getIntensity()*scale2));
				j++;
			}
		}
		
		//appending any remaining peaks 
		while(i < s1.peaks.size()){
			p1 = s1.peaks.get(i);
			this.peaks.add(new Peak(p1.getMass(), p1.getIntensity()));
			i++;
		}
		while(j < s2.peaks.size()){
			p2 = s2.peaks.get(j);
			this.peaks.add(new Peak(p2.getMass(), p2.getIntensity()*scale2));
			j++;
		}
		this.isSqrtTrans = s1.isSqrtTrans;
		this.rmagnitue = this.magnitude();//Math.pow(this.sumOfPeaks(), 0.5);
	}
	
	//same as above except this time we are not scaling the intensity
	public Spectrum(Spectrum s1, Spectrum s2){
		this(s1,s2,1,1);
	}
	
	public void setPeaks(List<Peak> peaks){
		this.peaks = peaks;
		this.rmagnitue = this.magnitude(); //Math.pow(this.sumOfPeaks(), 0.5);
	}
	
	public List<Peak> getPeak(){
		return this.peaks;
	}
	
	public void readSpectrumFromMSP(String fileName){
		try{
			BufferedReader bf = new BufferedReader(new FileReader(fileName));
			readSpectrumFromMSP(bf);
		 }catch(IOException ioe){
				System.out.println("Cannot Open MSP file");
				System.out.println(ioe.getMessage());			
		 }
	}
	
	public boolean readSpectrumFromMSP(BufferedReader bf) {

		try {
		
			String temp ;
    		int size ;
			String line;
			int mod ;
	
			boolean isPeaks = false; 
			String[] tokens;
		   	line = bf.readLine() ;
		   
   			while (line != null && line.length() != 0) {
	   			
	   			if(line.startsWith("Name:")){
	   				this.charge = Integer.valueOf((line.split("[ ,/]"))[2]);
					this.peptide = (line.split("[ ,/]"))[1];
					this.peptide = this.peptide + "." + this.charge;
				
				}else if(line.startsWith("Comment:")){
					temp = line.substring(line.indexOf("Parent")) ;
	    			this.parentMass = Double.parseDouble((temp.split("[=, ]"))[1] ) ;
	
					temp = line.substring(line.indexOf("Mods")) ;
			    	tokens = temp.split("[,,=, ,/]") ;
			
					mod = Integer.parseInt(tokens[1]) ;
	    	
			    	if (mod == 0) {
			 
			    		this.modPos = -1 ;
			    		this.modMass = 0 ;
			    			    	
			    	}
			   
			    	else {
			    		
			    		this.modPos = Integer.parseInt(tokens[2]) ;
			    		this.modMass = 100.00 ;
			    			 
			    	}
			
				}else if(line.startsWith("Num peaks:")){
					isPeaks = true ;
				
				}
				
				else if(isPeaks) {
					tokens = line.split("\t");
					this.peaks.add(new Peak(Double.valueOf(tokens[0]),
							Double.valueOf(tokens[1])));
				}
				line = bf.readLine();
			}
			this.rmagnitue = this.magnitude(); //Math.pow(this.sumOfPeaks(), 0.5);
			if(line == null){
				return false;
			}
   		  			
   		}catch(IOException ioe){
			System.out.println("Cannot Open MST file");
			System.out.println(ioe.getMessage());
			return false;
		}
		return true;
		
		
	}
	
	//read a spectrum from a MGF file
	public void readSpectrumFromMGF(String fileName){
		try{
			BufferedReader bf = new BufferedReader(new FileReader(fileName));
			readSpectrumFromMGF(bf);
		 }catch(IOException ioe){
				System.out.println("Cannot Open MGF file");
				System.out.println(ioe.getMessage());			
		 }
	}
	
	//read a spectrum from a buffer reader, this way
	//when we try to create multiple spectrums from MGF
	//we can pass the reader to it directly
	//note that means after calling this function we
	//read one subsequent spectra from the file
	public boolean readSpectrumFromMGF(BufferedReader bf){
		try{
			String line;
			do{
				line = bf.readLine();
				//System.out.println(line);
			}while(line != null && !line.equals("BEGIN IONS"));
			// a flag tell us whether we are in peak sections
            //in the spectrum file
			boolean isPeaks = false; 
			String[] token;
			String charge;
			line = bf.readLine();
			while(line != null && !line.equals("END IONS")){
				//System.out.println("line is " + line);
				if(line.startsWith("PEPMASS")){
					this.parentMass = Double.valueOf(((line.split("="))[1]));
					//isPeaks = true;  //for real data last line of mgf is pepmass
				}else if(line.startsWith("CHARGE")){
					charge = ((line.split("="))[1]);
					if(charge.startsWith("+")){
						charge = charge.substring(1);
					}
					this.charge = Integer.valueOf(charge);
					
				}else if(line.startsWith("PEPSEQ")){
					this.peptide = (line.split("="))[1];
					this.peptide = this.peptide + "." + this.charge;
				}else if(line.startsWith("TITLE")){
					this.peptide = (line.split("="))[1];
					this.peptide = this.peptide + "." + this.charge;
					this.spectrumName = (line.split("="))[1];
				}else if(line.startsWith("PEPMOD")){
					//just put some arbitary mod for now
					//mainly use this as a flag to tell spectra with mod
					//from those without any mod
					this.modMass = 50;
					this.modPos = 3;
					
				}else if(Character.isDigit(line.charAt(0))){
					//System.out.println("currelint is: " + line + "\tfirst: " + line.charAt(0));
					isPeaks = true;
					
				}
				if(isPeaks){
					token = line.split("\\s+");
					this.peaks.add(new Peak(Double.valueOf(token[0]) * 0.9995, //note multiply by 0.9995 to make peaks center around integer values
						  Double.valueOf(token[1])));   //squareroot transform of intensity, try stabalized peak intentsity variance
				}
				line = bf.readLine();
			}
			this.rmagnitue = this.magnitude(); //Math.pow(this.sumOfPeaks(), 0.5);
			if(line == null){
				return false;
			}
		}catch(IOException ioe){
			System.out.println("Cannot Open MGF file");
			System.out.println(ioe.getMessage());
			return false;
		}
		return true;
	}
	
	public int compareTo(Spectrum s){
		if(s.score == this.score){
			return 0;
		}else if(s.score < this.score){
			return 1;
		}else{
			return -1;
		}
	}
	//return a vector representation of the spectrum
	//where we bin the spectrums and sum up all the 
	//operationally this is just another spectrum with
	//whose x-coordinate of peaks are in the unit of bin-width
	//rather than in dalton, so it each peak will have 
	//an integer as their x-coordinate, e.g (1, 100.2) that means
	//we have a sum of peaks with total intensity 100.2 at bin 1 etc..
	public Spectrum toNormVector(double binWidth, double minMass, double maxMass){
		Spectrum newSpectrum = toVector(binWidth, minMass, maxMass);
		newSpectrum.normalize();
		return newSpectrum;
	}
	
	public Spectrum toNormVector(){
		
		return this.toNormVector(BINWIDTH, MINMASS, MAXMASS);
	}
	
	public Spectrum toVector(double binWidth, double minMass, double maxMass){
		int bins = (int)((maxMass-minMass)/binWidth) + 1;
		List <Peak>  newPeaks = new ArrayList();
		double rightBoundary = minMass + binWidth;
		double currentValue;
		double moz;
		int j = 0;
		int i = 0;
		//System.out.println("bins: " + bins);
  		for(i = 0; i < bins; i++){
			rightBoundary = minMass + i*binWidth;
			currentValue = 0;
			while(j < this.peaks.size()){
				moz = ((Peak)peaks.get(j)).getMass();
				//System.out.println("moz " + moz);
				//System.out.println("r-edge: " + rightBoundary);
				if(moz > rightBoundary){
					break;
				}else{
					currentValue += peaks.get(j).getIntensity(); 
					j++;
				}	
			}
			if(currentValue > 0){
				//System.out.println("creating new peaks");
				newPeaks.add(new Peak(i, currentValue));
			}
		}
		Spectrum newSpect = new Spectrum(newPeaks, this.peptide, this.parentMass, this.charge,
				this.modMass, this.modPos);
		newSpect.isSqrtTrans = this.isSqrtTrans;
		return newSpect;
	}
	
	//we normalize the intensity of the spectrum
	//so it is has norm one
	private void normalize(){
		double total = magnitude();
		this.scaleSpectrum(1/total);
		this.rmagnitue = this.magnitude(); //Math.pow(this.sumOfPeaks(), 0.5);
	}
	
	//if a intensity gets two large 
	//e.g. >90% of total intensity we 
	public boolean checkOutLiner(){
		int i = 0;
		double total = magnitude();
		for(i = 0; i < this.peaks.size(); i++){
			if(peaks.get(i).getIntensity() > 0.9*total){
				return true;
			}
		}
		return false;
	}
	//return the magnitue of this spectrum
	//now we are thinking a spectrum as a vector
	private double magnitude(){
		double total = 0;
		for(int i = 0; i < peaks.size(); i++){
			total += (peaks.get(i)).getIntensity() * (peaks.get(i)).getIntensity();
		}
		total = Math.pow(total, 0.5);
		return total;
	}
	
	//magnitude for sqrt the spectrum 
	public double sumOfPeaks(){
		double total = 0;
		for(int i = 0; i < peaks.size(); i++){
			total += (peaks.get(i)).getIntensity();
		}
		//total = Math.pow(total, 0.5);
		return total;
	}
	
	//we scale all the peaks in this spectrum by some factor
	public void scaleSpectrum(double factor){
		for(int i = 0; i < peaks.size(); i++){
			peaks.get(i).scaleIntensity(factor);
		}
	}
	
	//shift all masses in the spectrum by ceratin small mass
	public void shiftSpectrum(double shift){
		for(int i = 0; i < peaks.size(); i++){
			peaks.get(i).shiftMass(shift);
		}
	}
	
	//taking square root of all the intensity in spectrum
	//try to dampen the dominant effect of very high intensity
	public void sqrtSpectrum(){
		for(int i = 0; i < peaks.size(); i++){
			peaks.get(i).setIntensity(Math.pow(peaks.get(i).getIntensity(), 0.5));
		}
		this.isSqrtTrans = true;
		this.rmagnitue = this.magnitude();
	}
	//compare two spectrum by calculating their normalized dot product 
	//i.e. cosine of vector representation of spectrum
	public double cosineSim(Spectrum s1){
		double product = 0;
		double magnitude = this.rmagnitue; 
		magnitude *= s1.rmagnitue;
		//System.out.println("Matching  " + this.peptide + " with " + s1.peptide);
		double mz1, mz2; 
		int i = 0, j = 0;
		int size1 = this.peaks.size(), size2 = s1.peaks.size();
		while(i < size1 && j < size2){
			mz1 = this.peaks.get(i).getMass();
			mz2 = s1.peaks.get(j).getMass();
			if(mz1 < mz2){
				i++;
			}else if(mz1 == mz2){
				//System.out.println("matched " + mz1 + "\t" + this.peaks.get(i).getIntensity() + "\t" + s1.peaks.get(j).getIntensity());
				product += this.peaks.get(i).getIntensity()
					* s1.peaks.get(j).getIntensity();
				i++;
				j++;
			}else{
				j++;
			}

		}

		return product/magnitude;
		
	}
	
	//consine sim with sqrt normalization of peak intensities
	public double cosineSim1(Spectrum s1){
		double product = 0;
		double magnitude = Math.pow(this.sumOfPeaks(), 0.5); //this.rmagnitue; 
		magnitude *= Math.pow(s1.sumOfPeaks(), 0.5); //s1.rmagnitue;
		//System.out.println("Matching  " + this.peptide + " with " + s1.peptide);
		double mz1, mz2; 
		int i = 0, j = 0;
		int size1 = this.peaks.size();
		int size2 = s1.peaks.size();
		while(i < size1 && j < size2){
			mz1 = this.peaks.get(i).getMass();
			mz2 = s1.peaks.get(j).getMass();
			if(mz1 < mz2){
				i++;
			}else if(mz1 == mz2){
				//System.out.println("matched " + mz1 + "\t" + this.peaks.get(i).getIntensity() + "\t" + s1.peaks.get(j).getIntensity());
				product += Math.pow(this.peaks.get(i).getIntensity(), 0.5)
					* Math.pow(s1.peaks.get(j).getIntensity(), 0.5);
				i++;
				j++;
			}else{
				j++;
			}
		}
		if((magnitude) == 0){
			System.out.println(this.peptide + " and " + s1.peptide + " has similarity unknown");
			System.out.println("this has: " + this.peaks.size());
			System.out.println("s1 has: " + s1.peaks.size());
			return 0;
		}
		return product/magnitude;
		
	}
	
	//this method consider similarity of two spectrum
	//and their shifted variants, as different isotopic 
	//variants of same spectrum might have mass off 
	//by a small amount of mass/charge 
	//note this version should apply to the raw spectrum
	//i.e. without any normalization
	public double shiftCosineSim(Spectrum s1){
		Spectrum original = this.toNormVector();
		this.shiftSpectrum(0.5);
		Spectrum rightShift = this.toNormVector();
		this.shiftSpectrum(-1.0); //left shift original spectrum by -0.5 (0 + 0.5 - 1.0) = -0.5
		Spectrum leftShift = this.toNormVector(); 
		this.shiftSpectrum(0.5); //restore the original spectrum
		Spectrum vS1 = s1.toNormVector();
		double cosineOriginal = original.cosineSim(vS1);
		double cosineLeftShift = leftShift.cosineSim(vS1);
		double cosineRightShift = rightShift.cosineSim(vS1);
		//System.out.println("three version of cosine: " + cosineOriginal + ", " + cosineLeftShift + ", " + cosineRightShift);
		return Math.max(cosineRightShift, 
			Math.max(cosineOriginal, cosineLeftShift));
		
	}
	
	public double shareSim(Spectrum s1){
		double s = this.shareSim(s1, 0);
		return s;
	}
	
	//we calculate fraction of peaks share by the two spectrum,
	//there are three way we can calculate the fraction, which maybe useful at diff situation
	//mode: 0 , divide by average size of two spectrum being compare
	//mode: 1, divide by size of this spectrum
	//mode: 1, divide by size of s1
	public double shareSim(Spectrum s1, int mode){
		double product = 0;
		double magnitude = this.peaks.size(); 
		double magnitude2 = s1.peaks.size();
		//System.out.println("mixture magnitue " + s1.magnitude());
		double mz1, mz2; 
		int i = 0, j = 0;
		while(i < this.peaks.size() && j < s1.peaks.size()){
			mz1 = this.peaks.get(i).getMass();
			mz2 = s1.peaks.get(j).getMass();
			if(mz1 < mz2){
				i++;
			}else if(mz1 == mz2){
				product += 1;
				i++;
				j++;
			}else{
				j++;
			}
		}
		if(mode == 0){
			return product/((magnitude+magnitude2)/2);
		}else if(mode == 1){
			return product/100;
		}else{
			return product/magnitude2;
		}
		
	}
	
	//similar to calculating cosine of two vector
	//but here we consider only those bins
	//that are non-zero in this vector
	public double projectedCosine1(Spectrum s1){
		double product = 0;
		double magnitude = this.magnitude();
		//we do the dotproduct as above, but just calculates
		//the norm for s1 vector differently, we only consider
	 	//those values that are non-zero in this vector
		double projectedNorm = 0.00000001; //very small number avoid div-by-zero error  
		double mz1, mz2; 
		int i = 0, j = 0;
		//System.out.println("Matching  " + this.peptide + " with " + s1.peptide);
		while(i < this.peaks.size() && j < s1.peaks.size()){
			mz1 = this.peaks.get(i).getMass();
			mz2 = s1.peaks.get(j).getMass();
			if(mz1 < mz2){
				i++;
			}else if(mz1 == mz2){
				//System.out.println("matched " + mz1 + "\t" + this.peaks.get(i).getIntensity() + "\t" + s1.peaks.get(j).getIntensity());
				product += this.peaks.get(i).getIntensity()
					* s1.peaks.get(j).getIntensity();
				projectedNorm += s1.peaks.get(j).getIntensity() * s1.peaks.get(j).getIntensity();
				i++;
				j++;
			}else{
				j++;
			}
		}
		//System.out.println("this norm: " + this.magnitude());
		//System.out.println("mixture projected norm: " + Math.pow(projectedNorm, 0.5));
		magnitude = magnitude * Math.pow(projectedNorm, 0.5);
		return product/magnitude;
	}
	
	//similar to calculating cosine of two vector
	//but here we consider only those bins
	//that are non-zero in this vector
	public double projectedCosine(Spectrum s1){
		double product = 0;
		double magnitude = Math.pow(this.sumOfPeaks(), 0.5);
		//we do the dotproduct as above, but just calculate
		//the norm for s1 vector differently, we only consider
	 	//those values that are non-zero in this vector
		double projectedNorm = 0.00000001; //very small number avoid div-by-zero error  
		double mz1, mz2; 
		int i = 0, j = 0;
		//System.out.println("Matching  " + this.peptide + " with " + s1.peptide);
		while(i < this.peaks.size() && j < s1.peaks.size()){
			mz1 = this.peaks.get(i).getMass();
			mz2 = s1.peaks.get(j).getMass();
			if(mz1 < mz2){
				i++;
			}else if(mz1 == mz2){
				//System.out.println("matched " + mz1 + "\t" + this.peaks.get(i).getIntensity() + "\t" + s1.peaks.get(j).getIntensity());
				product += Math.pow(this.peaks.get(i).getIntensity()
					* s1.peaks.get(j).getIntensity(), 0.5);
				projectedNorm += s1.peaks.get(j).getIntensity();
				i++;
				j++;
			}else{
				j++;
			}
		}
		//System.out.println("this norm: " + this.magnitude());
		//System.out.println("mixture projected norm: " + Math.pow(projectedNorm, 0.5));
		magnitude = magnitude * Math.pow(projectedNorm, 0.5);
		return product/magnitude;
	}
	
	
	public double alpha(Spectrum a, Spectrum b) {		
		double A, B, C, D, E ;		
		C = this.dot(a) ;
		D = a.dot(b) ;
		E = this.dot(b) ;
		A = a.dot(a) ;
		B = b.dot(b) ;
		double alpha = ((B*C)-(D*E) )/ ((A*E)-(C*D));
//		if(alpha > 0){  //there is some strange cases where alpha is < 0
//			return alpha;
//		}else{
//			//System.out.println("warning alpha smaller than zero");
//			return -1*alpha;
//		}
		//we restrict alpha to be smaller than 10, i.e. we require the relative fraction to be no more than 1:10
		if(alpha < 0.1 || alpha > 10){
			return alpha;
		}else{
			return alpha;  //  alpha;
		}
	}
	
	public double maxScore(Spectrum a, Spectrum b, double alpha){
		//System.out.println("alpha is: " + alpha);
		//alpha = 0.1;
		Spectrum answerMix1 = new Spectrum(a, b, alpha, 1) ;
		Spectrum answerMix2 = new Spectrum(b, a, alpha, 1) ;
	    //answerMix1.filterPeaks(100);
	    //answerMix2.filterPeaks(100);
		//answerMix1.sqrtSpectrum();
		//answerMix2.sqrtSpectrum();
	
		//double score1 = (this.dot(answerMix1)) / (this.sumOfPeaks() * answerMix1.sumOfPeaks()) ; 
		//double score2 = (this.dot(answerMix2)) / (this.sumOfPeaks() * answerMix2.sumOfPeaks()) ; 
		double score1 = this.cosineSim(answerMix1);
		double score2 = this.cosineSim(answerMix2);
		//double score1 = this.shiftCosineSim(answerMix1);
		//double score2 = this.shiftCosineSim(answerMix2);
	
		if (score1 > score2)
			return score1 ;
		else
			return score2 ;
	
	}
	
	
	//shift-version of maxscore, we actually need to try all combination
	/*public double shiftMaxScore(Spectrum a, Spectrum b, double alpha){
	    Spectrum normVa = a.toNormVector();
	    Spectrum normVb = b.toNormVector();
	    
	    Spectrum original = this.toNormVector();
		this.shiftSpectrum(0.5);
		Spectrum rightShift = this.toNormVector();
		this.shiftSpectrum(-1.0); //left shift original spectrum by -0.5 (0 + 0.5 - 1.0) = -0.5
		Spectrum leftShift = this.toNormVector(); 
		this.shiftSpectrum(0.5); //restore the original spectrum
		
		alpha = original.alpha(normVa, normVb);
		double maxOriginal = original.maxScore(normVa, normVb, alpha);
		alpha = rightShift.alpha(normVa, normVb);
		double maxRight = rightShift.maxScore(normVa, normVb, alpha);
		alpha = leftShift.alpha(normVa, normVb);
		double maxLeft = leftShift.maxScore(normVa, normVb, alpha);
		return Math.max(maxLeft,
				Math.max(maxRight, maxOriginal));
	}*/
	
	public double shiftMaxScore(Spectrum a, Spectrum b, double alpha){
	    Spectrum origA = a.toNormVector();
	    a.shiftSpectrum(0.5);
	    Spectrum rightA = a.toNormVector();
	    a.shiftSpectrum(-1.0);
	    Spectrum leftA = a.toNormVector();
	    a.shiftSpectrum(0.5);
	    Spectrum origB = b.toNormVector();
	    b.shiftSpectrum(0.5);
	    Spectrum rightB = b.toNormVector();
	    b.shiftSpectrum(-1.0);
	    Spectrum leftB = b.toNormVector();
	    b.shiftSpectrum(0.5);
	    Spectrum mix = this.toNormVector();
	    
	    double best = 0, bestalpha;
	    alpha = mix.alpha(origA, origB);
		best = Math.max(best, mix.maxScore(origA, origB, alpha));
		alpha = mix.alpha(origA, leftB);
		best = Math.max(best, mix.maxScore(origA, leftB, alpha));
		alpha = mix.alpha(origA, rightB);
		best = Math.max(best, mix.maxScore(origA, rightB, alpha));
		
		alpha = mix.alpha(leftA, origB);
		best = Math.max(best, mix.maxScore(leftA, origB, alpha));
		alpha = mix.alpha(leftA, leftB);
		best = Math.max(best, mix.maxScore(leftA, leftB, alpha));
		alpha = mix.alpha(leftA, rightB);
		best = Math.max(best, mix.maxScore(leftA, rightB, alpha));
		
		alpha = mix.alpha(rightA, origB);
		best = Math.max(best, mix.maxScore(rightA, origB, alpha));
		alpha = mix.alpha(rightA, leftB);
		best = Math.max(best, mix.maxScore(rightA, leftB, alpha));
		alpha = mix.alpha(rightA, rightB);
		best = Math.max(best, mix.maxScore(rightA, rightB, alpha));
		
		return best;
		
	}
	
	//this is an inverse of max score in the sense that rather than dampening the
	//effect of "weaker" spectrum, we actually try to magnify it in the mixture
	//so we pay roughly same attention to both spectrum
	public double inverseMaxScore(Spectrum a, Spectrum b, double alpha){
		//alpha = 10;
		//b.filterPeaks(20);
		Spectrum answerMix = new Spectrum(a, b);
		Spectrum mix = this.toNormVector();
		//mix = this.toNormVector();
		mix.upscale(a, b, alpha);
		//answerMix = answerMix.toNormVector();
		//System.out.println("one part: " + mix.cosineSim(a));
		//System.out.println("second part: " + mix.cosineSim(b));
		//System.out.println("both parts together: " + mix.cosineSim(answerMix));
		//System.out.println(answerMix);
		//System.out.println(mix);
		//System.out.println(a);
		//System.out.println(b);
		return mix.cosineSim(answerMix);
	}
	
	//transforming a mixture spectrum by upscaling one of its component
	//note here we made assumption alpha > 1, need to see cases where it is smaller
	//than one to see if the procedure still hold
	public void upscale(Spectrum s1, Spectrum s2, double alpha){
		//System.out.println(s1);
		//System.out.println(s2);
		double mz1, mz2, mz3; 
		int i = 0, j = 0, k=0;
		double intensity;
		while(i < this.peaks.size() && j < s2.peaks.size()){
			mz1 = this.peaks.get(i).getMass();
			mz2 = s2.peaks.get(j).getMass();
			if(k >= s1.peaks.size()){
				mz3 = 3000; //a really big mass
			}else{
				mz3 = s1.peaks.get(k).getMass();
			}
			if(mz1 < mz2){
				i++;
			}else if(mz3 < mz2){
				k++;
			}else if(mz1 == mz2 && mz3 > mz2){
				if(s2.peaks.get(j).getIntensity() > 0.1){
					//System.out.print("s2 intensity: " + s2.peaks.get(j));
					//System.out.print("unscaled intensity: " + this.peaks.get(i));
					this.peaks.get(i).scaleIntensity(alpha+1); //upscale mix intensity
					//System.out.println("scaled intensity: " + this.peaks.get(i).getIntensity());
				}
				i++; 
				j++;
			}else if(mz1 == mz2 && mz1 == mz3){
				if(s2.peaks.get(j).getIntensity() > 0.1){
					intensity = this.peaks.get(i).getIntensity();
					intensity = (intensity - (s1.peaks.get(k).getIntensity()));
					//System.out.print("s2 intensity: " + s2.peaks.get(j));
					//System.out.print("combined intensity: " + this.peaks.get(i));
					//System.out.print("s1 intensity: " + s1.peaks.get(k));
					//System.out.println("subtracted intensity: " + intensity);
					intensity = intensity*(alpha+1);	
					//System.out.println("scaled intensity: " + intensity*(alpha+1));
					if(intensity > 0){
						this.peaks.get(i).setIntensity(this.peaks.get(i).getIntensity() + intensity);
					}
					//System.out.println("final combined intensity: " + this.peaks.get(i));
					
				}
				i++; 
				j++; 
				k++;
			}else{
				j++;
			}
		}
	}
	
	public double dot(Spectrum s1) {
		double product = 0;
		double mz1, mz2; 
		int i = 0, j = 0;
		
		while(i < this.peaks.size() && j < s1.peaks.size()){
			mz1 = this.peaks.get(i).getMass();
			mz2 = s1.peaks.get(j).getMass();
			if(mz1 < mz2){
				i++;
			}else if(mz1 == mz2){
				//System.out.println("Intensity are: " + this.peaks.get(i).getIntensity() + "\t" + s1.peaks.get(j).getIntensity());
				if(this.isSqrtTrans){
					product += this.peaks.get(i).getIntensity() * this.peaks.get(i).getIntensity()
					 	* s1.peaks.get(j).getIntensity() * s1.peaks.get(j).getIntensity();
				}else{
					product += Math.pow(this.peaks.get(i).getIntensity(), 1)
						* Math.pow(s1.peaks.get(j).getIntensity(), 1);
				}
				i++;
				j++;
			}else{
				j++;
			}
		}
				
		return product ;
	}
	
	
	//remove peaks that present in both spectrum from this spectrum
	//if magnitue is not the same subtract the intesity of s from this peaks
	//if the resulting peaks is less than zero then the peaks is removed
	public void removeSharePeaks(Spectrum s){
		Iterator<Peak> p1 = this.peaks.iterator();
		Iterator<Peak> p2 = s.getPeak().iterator();
		Peak peak1 = null, peak2 = null;
		if(p1.hasNext() && p2.hasNext()){
			peak1 = p1.next();
			peak2 = p2.next();
		}else{
			return;
		}
		while(p1.hasNext() && p2.hasNext()){
			if(peak1.getMass() < peak2.getMass()){
				peak1 = p1.next();
			}else if(peak1.getMass() == peak2.getMass()){
				p1.remove();
				peak1 = p1.next();
				peak2 = p2.next();
			}else{
				peak2 = p2.next();
			}
		}
		if(peak1.getMass() == peak2.getMass()){ //take care of last element
				p1.remove();
		}
		
	}	
	
	//rather than removing the share peaks, we substract the share
	//peaks from this spectrum, this method is destructive
	public void subtractSharePeaks(Spectrum s){
		Iterator<Peak> p1 = this.peaks.iterator();
		Iterator<Peak> p2 = s.getPeak().iterator();
		Peak peak1 = null, peak2 = null;
		if(p1.hasNext() && p2.hasNext()){
			peak1 = p1.next();
			peak2 = p2.next();
		}else{
			return;
		}
		while(p1.hasNext() && p2.hasNext()){
			if(peak1.getMass() < peak2.getMass()){
				peak1 = p1.next();
			}else if(peak1.getMass() == peak2.getMass()){
				peak1.setIntensity(peak1.getIntensity() - peak2.getIntensity());
				if(peak1.getIntensity() < 0){
					p1.remove();
				}
				peak1 = p1.next();
				peak2 = p2.next();
			}else{
				peak2 = p2.next();
			}
		}
		if(peak1.getMass() == peak2.getMass()){ //take care of last element
				p1.remove();
		}
		
	}
	
	public double residual(Spectrum s){
		Iterator<Peak> p1 = this.peaks.iterator();
		Iterator<Peak> p2 = s.getPeak().iterator();
		Peak peak1 = null, peak2 = null;
		int exp;
		if(this.isSqrtTrans){
			exp = 4;
		}else{
			exp = 2;
		}
		double shareIntensity = 0;
		double residIntensity = 0.000000001; //avoid div-by-zero 
		if(p1.hasNext() && p2.hasNext()){
			peak1 = p1.next();
			peak2 = p2.next();
		}else{
			return shareIntensity/residIntensity;
		}
		double remain;
		//System.out.println("magnitude is: " + this.magnitude());
		while(p1.hasNext() && p2.hasNext()){
			if(peak1.getMass() < peak2.getMass()){
				residIntensity += Math.pow(peak1.getIntensity(),exp);
				//System.out.println("res intensity: " + peak1.getMass() + "\t" + peak1.getIntensity());
				peak1 = p1.next();
			}else if(peak1.getMass() == peak2.getMass()){
				remain = peak1.getIntensity() - peak2.getIntensity();
				if(remain < 0){
					remain = 0;
				}
				shareIntensity += Math.pow(peak1.getIntensity(),exp);
				//System.out.println("share: " + peak2.getMass() + "\t" + peak2.getIntensity());
				//System.out.println("remaining: " + peak1.getMass() + "\t" + remain);
				//residIntensity += Math.pow(remain,exp);
				peak1 = p1.next();
				peak2 = p2.next();
			}else{
				//shareIntensity += Math.pow(peak1.getIntensity(), 2);
				peak2 = p2.next();
			}
		}
		
		if(peak1.getMass() == peak2.getMass()){ //take care of last element
				shareIntensity += Math.pow(peak1.getIntensity(), exp);
				remain = peak1.getIntensity() - peak2.getIntensity();
				if(remain < 0){
					remain = 0;
				}
				//residIntensity += Math.pow(remain, 2);
		}
		if(!p1.hasNext()){
			residIntensity += Math.pow(peak1.getIntensity(), exp);
		}
		
//		if(!p2.hasNext()){
//			shareIntensity += Math.pow(peak2.getIntensity(), 2);
//			//System.out.println("share: " + peak2.getMass() + "\t" + peak2.getIntensity());
//		}
		
		while(p1.hasNext()){
			residIntensity += Math.pow(p1.next().getIntensity(), exp);
		}
		
//		while(p2.hasNext()){
//			shareIntensity += Math.pow(p2.next().getIntensity(), 2);
//		}
			
		//System.out.println("shareIntensity: " + Math.pow(shareIntensity,0.5));
//		System.out.println("s has intensity: " + s.magnitude());
		//System.out.println("resIntensity: " + Math.pow(residIntensity,0.5));
		//double alpha = Math.pow(shareIntensity/residIntensity, 0.5); //initial estimate
		double alpha = Math.pow(residIntensity, 0.5);
		//System.out.println("alpha: " + alpha);
		alpha = alpha*alpha / (1-alpha*alpha);  //reestimate by taking into account that mixture is normalized to one
		return Math.pow(alpha, 0.5); //thus each component is down-weighted slightly
		//return alpha;
	}
	
	public double residualIntensity(Spectrum s){
		Iterator<Peak> p1 = this.peaks.iterator();
		Iterator<Peak> p2 = s.getPeak().iterator();
		Peak peak1 = null, peak2 = null;
		double shareIntensity = 0;
		double residIntensity = 0.000000001; //avoid div-by-zero 
		if(p1.hasNext() && p2.hasNext()){
			peak1 = p1.next();
			peak2 = p2.next();
		}else{
			return shareIntensity/residIntensity;
		}
		double remain;
		while(p1.hasNext() && p2.hasNext()){
			if(peak1.getMass() < peak2.getMass()){
				residIntensity += Math.pow(peak1.getIntensity(),1);
				//System.out.println("res intensity: " + peak1.getMass() + "\t" + peak1.getIntensity());
				peak1 = p1.next();
			}else if(peak1.getMass() == peak2.getMass()){
				remain = peak1.getIntensity() - peak2.getIntensity();
				if(remain < 0){
					remain = 0;
				}
				shareIntensity += Math.pow(peak2.getIntensity(),1);
				//System.out.println("share: " + peak2.getMass() + "\t" + peak2.getIntensity());
				//System.out.println("remaining: " + peak1.getMass() + "\t" + remain);
				residIntensity += Math.pow(remain,2);
				peak1 = p1.next();
				peak2 = p2.next();
			}else{
				shareIntensity += Math.pow(peak2.getIntensity(), 1);
				peak2 = p2.next();
			}
		}
		
		if(peak1.getMass() == peak2.getMass()){ //take care of last element
				shareIntensity += Math.pow(peak2.getIntensity(), 1);
				remain = peak1.getIntensity() - peak2.getIntensity();
				if(remain < 0){
					remain = 0;
				}
				//residIntensity += Math.pow(remain, 2);
		}
		if(!p1.hasNext()){
			residIntensity += Math.pow(peak1.getIntensity(), 1);
		}
		
		if(!p2.hasNext()){
			shareIntensity += Math.pow(peak2.getIntensity(), 1);
			//System.out.println("share: " + peak2.getMass() + "\t" + peak2.getIntensity());
		}
		
		while(p1.hasNext()){
			residIntensity += Math.pow(p1.next().getIntensity(), 1);
		}
		
		while(p2.hasNext()){
			shareIntensity += Math.pow(p2.next().getIntensity(), 1);
		}
			
		System.out.println("shareIntensity: " + Math.pow(shareIntensity, 1));
//		System.out.println("s has intensity: " + s.magnitude());
		System.out.println("resIntensity: " + Math.pow(residIntensity, 1));
		return Math.pow(shareIntensity/residIntensity, 1);
		
	}
	
	//filter the spectrum and only keep top n peaks
	public void filterPeaks(int n){
		Vector<Peak> sortedPeakList = new Vector<Peak>();
		sortedPeakList.addAll(this.peaks);
		Collections.sort(sortedPeakList, new peakComaparator());
		int i = 0;
		Peak p;
		for(i = 0; i < sortedPeakList.size() - n - 1; i++){
			this.peaks.remove(sortedPeakList.get(i));
		}
		this.rmagnitue  = this.magnitude();//Math.pow(this.sumOfPeaks(), 0.5);
	}
	
	//window based filtering, for every peak m, we look in
	//the range +/- deltaM from m and see if peak m is ranked
	//top n peaks in the window if it is, the peak is kept otherwise it isremoved
	public void windowFilterPeaks(int n, double deltaM){
		int i = 0;
		Peak p;
		List<Peak> toBeRemove = new ArrayList();
		List<Peak> neighbors = new ArrayList();
		for(int j = 0; j < this.peaks.size(); j++){
			p = this.peaks.get(j);
			//System.out.println("we had " + neighbors.size() + " neighbors");
			removeNonNeighborPeaks(deltaM, neighbors, p);
			//System.out.println("we have " + neighbors.size() + " remaining neighbors");
			i = addNeighborPeaks(deltaM, neighbors, p, i);
			//System.out.println("we end up with " + neighbors.size() + " neighbors this time");
			Vector sortedNeighbors = new Vector(neighbors);
			Collections.sort(sortedNeighbors, new peakComaparator());
			//System.out.println("rank is: " + getPeakRank(sortedNeighbors, p));
			if(getPeakRank(sortedNeighbors, p) > n){
				toBeRemove.add(p);
			}
		}
		System.out.println("We start with " + peaks.size() + " peaks");
		this.peaks.removeAll(toBeRemove);
		this.rmagnitue = this.magnitude(); //Math.pow(this.sumOfPeaks(), 0.5);
		System.out.println("After window-filtering we have: " + peaks.size() + " peaks");		
	}
	
	//assume peaks are sorted by mass
	private int addNeighborPeaks(double deltaM, List<Peak> neighbors, Peak p, int beginInd){
		boolean beginFlag = false;
		for(int i = beginInd; i < this.peaks.size(); i++){
			if(Math.abs(peaks.get(i).getMass() - p.getMass()) <= deltaM){
				neighbors.add(peaks.get(i));
				beginFlag = true;
			}else if(beginFlag){
				return i;
			}else if(beginFlag && i == this.peaks.size()-1){
				return i+1;
			}
		}
		return beginInd;
		
	}
	
	private void removeNonNeighborPeaks(double deltaM, List<Peak> neighbors, Peak p){
		Iterator<Peak> it = neighbors.iterator();
		while(it.hasNext()){
			if(Math.abs(it.next().getMass() - p.getMass()) > deltaM){
				it.remove();
			}
		}
	}
	
	private int getPeakRank(List<Peak> l, Peak p){
		for(int i = 0; i < l.size(); i++){
			if(l.get(i).equals(p)){
				return l.size()-i;
			}
		}
		return -1;
	}
	
	//return the minimum number of peaks that exaplained
	//a percentage of total intensity, this way we do not
	//account for very low-intensity peaks that are likely
	//to be noise rather than true signal
	public int numberOfPeaks(double percent){
		Vector<Peak> sortedPeakList = new Vector<Peak>();
		sortedPeakList.addAll(this.peaks);
		Collections.sort(sortedPeakList, new peakComaparator());
		//double total = this.magnitude();
		double total = 0;
		int i = 0, count = 0;
		for(i = sortedPeakList.size()-1; i >= 0; i--){
			total += sortedPeakList.get(i).getIntensity();
		}
		double current = 0;
		for(i = sortedPeakList.size()-1; i >= 0; i--){
			current += sortedPeakList.get(i).getIntensity();
			 //*sortedPeakList.get(i).getIntensity();
			if(current / total >= percent){
				//System.out.println("percent is: " + m/total);
				return ++count;
			}else{
				count++;
			}
			
		}
		return count;
	}
	
	//printout the spectrum for us to see, using default MGF format
	public String toString(){
		StringBuffer sb = new StringBuffer();
		sb.append("BEGIN IONS\n");
		sb.append("TITLE=" + this.spectrumName + "\n");
		sb.append("CHARGE=" + charge + "\n");
		sb.append("PEPMASS=" + parentMass + "\n");
		//sb.append("PEPSEQ=" + peptide + "\n");
		//sb.append("PEPEXP=" + 0.00000001+ "\n"); //generic expect value
		//sb.append("PEPMOD=" + modMass + "@" + modPos + "\n");
		//sb.append("GPMp\n");	
		for(int i = 0; i < peaks.size(); i++){
			sb.append(peaks.get(i));
		}
		sb.append("END IONS\n");
		return sb.toString();
	}
	
	public static void main(String[] args){
		testReadMGF();
		testtoVector();
		testVectorRep();
		testMixSpect();
		testRemoveSharePeak();
		testPeakCount();
		//testfilterPeak();
		testWindowFilterPeak();
		testShiftCosine();
		testResAlpha();
		testCreateMix();
	}
	//the following are simple test cases for various functions
	public static void testReadMGF(){
		String filename = "testspectrum.mgf";
		Spectrum msms = new Spectrum();
		msms.readSpectrumFromMGF(filename);
		System.out.print(msms);
	}
	
	public static void testtoVector(){
		System.out.println("generating vectored spectrum");
		String filename = "testspectrum.mgf";
		Spectrum msms = new Spectrum();
		msms.readSpectrumFromMGF(filename);
		Spectrum s = msms.toVector(50, 100, 500);
		System.out.println(s);
	}
	
	public static void testVectorRep(){
		String filename = "testspectrum.mgf";
		Spectrum msms = new Spectrum();
		msms.readSpectrumFromMGF(filename);
		Spectrum msms2 = new Spectrum();
		msms2.readSpectrumFromMGF(filename);
		System.out.println("Comparing self to self: "
				+ msms2.cosineSim(msms));
	
		msms = msms.toNormVector(0.5, 100, 500);
		msms2 = msms2.toNormVector(0.5, 100, 500);
		System.out.println("Comparing self to self: "
				+ msms2.cosineSim(msms));
		System.out.println("scaling one copy of self");
		msms.scaleSpectrum(0.03);
		System.out.println("Comparing self to self: "
				+ msms2.cosineSim(msms));
		System.out.println();
	
	
	}
	
	public static void testMixSpect(){
		System.out.println("generating mix spectrum");
		String filename = "testspectrum.mgf";
		Spectrum s1 = new Spectrum();
		s1.readSpectrumFromMGF("testspectrum.mgf");
		Spectrum s2 = new Spectrum();
		s2.readSpectrumFromMGF("testspectrum2.mgf");
		Spectrum msms12 = new Spectrum(s1, s2);
		s1=s1.toNormVector();
		s2=s2.toNormVector();
		System.out.println(s1);
		System.out.println(s2);
		System.out.println(msms12);
		System.out.println("cosine: " + s2.cosineSim(msms12));
		System.out.println("projected: " + s2.projectedCosine(msms12));
		System.out.println("cosine: " + s1.cosineSim(msms12));
		System.out.println("projected: " + s1.projectedCosine(msms12));
		System.out.println("distinct: " + s1.cosineSim(s2));
		System.out.println("distinct projected: " + s1.projectedCosine(s2));
	}
	
	public static void testRemoveSharePeak(){
		String filename = "testspectrum.mgf";
		Spectrum msms = new Spectrum();
		msms.readSpectrumFromMGF(filename);
		Spectrum msms2 = new Spectrum();
		msms2.readSpectrumFromMGF(filename);
		System.out.println("original spectrum");
		System.out.println(msms);
		System.out.println("removing self against self");
		msms.removeSharePeaks(msms2);
		System.out.println(msms);
		msms.readSpectrumFromMGF(filename);
		msms.peaks.get(0).setMoz(20);  //manually changing the first peak 
		System.out.println(msms);
		System.out.println("removing all but the first peak");
		msms.removeSharePeaks(msms2);
		System.out.println(msms);
	}
	
	public static void testPeakCount(){
		String filename = "testspectrum.mgf";
		Spectrum msms = new Spectrum();
		msms.readSpectrumFromMGF(filename);
		System.out.println(msms);
		System.out.println("total magnitude: " + msms.magnitude());
		for(double i = 0; i < 11; i++){
			System.out.println("number of peaks at" +  (i*10) +  "%: " + msms.numberOfPeaks(i/10));
		}
		
	}
	
	public static void testfilterPeak(){
		String filename = "testspectrum.mgf";
		Spectrum msms = new Spectrum();
		msms.readSpectrumFromMGF(filename);
		System.out.println(msms);
		System.out.println("total magnitude: " + msms.magnitude());
		for(int i = 20; i > 0; i--){
			msms.filterPeaks(i);
			System.out.println(msms);
		}
	}
	
	public static void testWindowFilterPeak(){
		String filename = "testspectrum.mgf";
		Spectrum msms = new Spectrum();
		msms.readSpectrumFromMGF(filename);
		System.out.println("before window filter: ");
		System.out.println(msms);
		msms.windowFilterPeaks(2, 50);
		System.out.println("after window filter: ");
		System.out.println(msms);
	}
	
	public static void testShiftCosine(){
		String filename = ".\\mixture_compressed\\new80min.mgf";
		String fileMix = ".\\mixture_compressed\\new2min.mgf";
        SpectrumLib lib1 = new SpectrumLib(filename, "MGF");
		SpectrumLib mixlib = new SpectrumLib(fileMix, "MGF");
		Spectrum s = lib1.getSpectra("spec_3182.dta..1").get(0);
		Spectrum m = mixlib.getSpectra("spec_186.dta..1").get(0);
		Spectrum sCopy = s;
		System.out.println("shift cosine: " + s.shiftCosineSim(m));
		System.out.println("shift cosine: " + s.shiftCosineSim(m));
		System.out.println("shift cosine: " + m.shiftCosineSim(s));
		System.out.println("");
		System.out.println("shift cosine with self: " + s.shiftCosineSim(sCopy));
		System.out.println("shift cosine with self: " + sCopy.shiftCosineSim(s));
		System.out.println("");
		s = s.toNormVector();
		sCopy = sCopy.toNormVector();
		System.out.println("cosine: " + s.cosineSim(sCopy));
		System.out.println("cosine: " + sCopy.cosineSim(s));

	}
	 public static void testResAlpha(){
		 String filename = "testspectrum.mgf";
		 Spectrum s1 = new Spectrum();
		 s1.readSpectrumFromMGF("testspectrum.mgf");
		 Spectrum s2 = new Spectrum();
		 s2.readSpectrumFromMGF("testspectrum2.mgf");
		 s1 = s1.toNormVector();
		 s2 = s2.toNormVector();
		 System.out.println(s1);
		 System.out.println(s2);
		 Spectrum m = new Spectrum(s1, s2, 1, 0.1);
		 m.toNormVector();
		 System.out.println(m);
		 m.residual(s1);
			
	 }
	 public static void testCreateMix(){
			String filename = "testspectrum.mgf";
			Spectrum s1 = new Spectrum();
			s1.readSpectrumFromMGF("testspectrum.mgf");
			Spectrum s2 = new Spectrum();
			s2.readSpectrumFromMGF("testspectrum2.mgf");
			s1 = s1.toNormVector();
			s2 = s2.toNormVector();
			Spectrum mix1 = new Spectrum(s1, s2, 1, 1);
			System.out.println(s1.toNormVector());
			System.out.println(s2.toNormVector());
			System.out.println(mix1);
			mix1.sqrtSpectrum();
			//mix1 = mix1.toNormVector();
			System.out.println(mix1);
			s1.sqrtSpectrum();
			s2.sqrtSpectrum();
			System.out.println("=============");
			System.out.println(s1.toNormVector());
			System.out.println(s2.toNormVector());
			Spectrum mix2 = new Spectrum(s1, s2, 1, 1);
			//mix2 = mix2.toNormVector();
			System.out.println(mix2);
			System.out.println(mix1.cosineSim(mix2));
	}

	//a simple comparator that compare the intensity of peaks
	private class peakComaparator implements Comparator<Peak>{ 
		public int compare(Peak p0, Peak p1) {
			if(p0.getIntensity()> p1.getIntensity()){
				return 1;
			}else if(p0.getIntensity() == p1.getIntensity()){
				return 0;
			}else{
				return -1;
			}
		}
	}
	
	
}


 